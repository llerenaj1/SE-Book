

# "Uncle" Bob Martin - "The Future of Programming" : Summary
[2017/11/01]
time keeping: 15 minutes + 1 hour 2 minutes 50 seconds

The reasons for there being so many languages and for languages to keep on being created is because people each have their own preferences. Bob Martin says that the industry should try to stop this search for the perfect programming language and just have one that is standardized so that people can just then focus on their work.
The programming industry used to not be so male dominated. What happened? We first must look at the past of programming and examine what exactly happened.

Alan Turing was one of the first to write code. He did so in Binary (reversed) in 1945. He used the integer adding and also the logical not. During this time he invented subroutines, code stack, and floating point amongst many other things. To say the least he was an inovator and a genius in his time. He, many years ago, foresaw the problems that may come in the future. He said that there will be a  great need for mathematicians of ability, because there will be a good deal of work of this kind to be done. I think what he was referring to is that he foresaw the potential that this industry had. He certainly saw it with innovations in hardware that allowed processes to be faster, or for memory to be greater. But he was wise enough to see the complexity that will arise because of the innovations. Another comment that Turing had on our future was that "one of our difficulties will be the maintenance of an appropriate discipline, so that we do not lose track of what we are doing". I had looked up this quote and there is an additional comment that he made that I think is interesting. Turing then says "we shall need a number of efficient librarian types to keep us in order." I see this as intereting because there are different practicies nowadays that deals with the documentation of things that we do when we build software. Common to this is agile and waterfall. Agile seems to not care too much or have too much emphasis in keeping documentation where waterfall is very intensive on keeping documentation at all stages. But Alan did see the big picture afterall, many many years before it came into the complex industry it is today. He understood that it would take certain measure to manage all the complexity.

Lisp was the beginning of functional programming and today lisp continues to stay relevant today and "won't die" occording to Bob Martin. Following suit were the beginnings of object oriented programming and structure programming. People such as Ken Thompson and Dinnis Ritchie came up with C and unix. What do all these creators of these wonderful and influential programming languages and practices have in common? They were all disciplined individuals coming from some sort of other background of studies. 

Throughout time and histor yof programming we see the evolution of the hardware in the tubes to transitors. We also see the change from people that were programmers being middle aged people comming from engineering, science, and mathematics; to being younger people learning these things in school and specializing in it alone. Programmings back in the day were experienced, disciplined, professionals, and they had these qualities because they were already working for a long time. This was in 1965, but there were still not enough programmers to be found. 

It was around the 1970's that there were people coming out of college with degrees in Computer Science, this is 25+ years after the some of the first programming and computers occured. A common thing amongst those grads, were that they were all young and that most of them were male. Before this "new age" of programmers, the programmers before them had worked miracles and they were all very disciplined professionals. They came up with things such as the IBM 360 and languages such as COBOL, FORTRAN, C, LISP, UNIX; practices such as Structured, Functional, and Object Oriented programming, and were used in businesses everwhere.  

Martin then goes on to say that if we were to go back and see how these early, older aged people, came to have such successes we would see that they have an Agile mindset or process. They were able to work hard in short periods of time per iteration, because (again and again emphasied in the video) they were disciplined professionals. It is intersting to hear that the start of the Waterfall process began with the age of programming where a male-dominated generation of new programmers, where they weren't too organized or able to manage things quite as well as professionals did. They needed close management and a fixed process, and that's where Waterfall came from. This "Waterfall Era" started in the 1970's.

Martin then goes on to make an intersting point that our industry will always be in a perpetual state of having programmers that don't have that much experience. This is because the number of programmers doubles each year. He says this problem will continue to happen every year. So now, the industry is mostly males, but the in terms of hardware things have progressed exponentially. Software-wise, not much has changed. The breakthrough, it seems from listening to Bob Martin talk, is that we must try to achieve the level of Software Professionalism that we saw in the first iteration of programmers where they were all experienced and disciplined individuals. There is a realization that the waterfall era has to change. 

Discipline is one of the key components in Agile. It requires working with fixed (mostly short) time frames, requires a lot of communication with the customer, it requires continuous integration, a high requirement of collaboration with others, and the process of estimation to break down tasks. It's interesting to view those list of things as a promise, Bob calls is, rather than steps you have to take. Agile seems to be a mindset that one has to truly believe in and live it out. 

The goal for Agile was initially to heal the divide between business and programming. But, it seems to do just the opposite. 1:11:00

Make point of how integrated programming is to our daily lives now. It's in everything that we do. Shop online. Car = tons of programmings. But having this so tightly knit in our lives comes with some sort of responsibility. People can blame software engineers for stuff that could even maybe include death. To avoid that, is to regulate ourselves first, self discipline. before an accident happens so that the government has to become involved. That in itslef and in short is the future of programming. 

# Reading Revenge of the nerds chapter 
Time: 31 minutes 21 seconds.. 15 minutes 23 seconds..
I just thought it was interesting how Graham starts off by saying that there is a problem in the software business where the "pointy-haried" boss is someone that encapsulates the qualities of knowing nothing about the technology that they are working with and having strong opinions about technology. The reason I thought this was interesting is that I myself am questioning if this is actually a huge problem in the software business or if Graham is just blowing hot air from bad experiences that he has had personally. Anyways, it was an eye opening opening remark in the first place. I wonder if I will encounter one of these pointy-haired bosses. When I think about current popular and thriving companies I can't really catergorize them the same way that Graham points out the bosses to be. They all seem to be well versed and passionate about the technology that they are producing and working with. 

One of the points in this chapter was that each programming languages has their own uses and some have more power over the others, but these strengths and weaknesses are usually unknown to people outside the coding community. Here, Graham again makes a point to say this is why the corperate managers/bosses have the weakness of not knowing what they are talking about. With the claim that bosses don't know much about all the programming languages, they would say the language to write programs with would be Java. Graham says the reason why the bosses say Java, is because it has become a corporate "standard" since everyone else is doing it, and it's a safe bet to use the same language as everyone else. This is because they believe that all languages are equal and so why not just use what everyone is using. There are just too many different variables to think about if one were to compare and contrast each major programming language when deciding on which one to use for the company. 

Graham says that the newest (and coolest) programming languages such as Java, Python, Perl, and Ruby are all like Lisp. So is Lisp the best software language that there is? All these new programming language seem to come from the longstanding Lisp. One great power that Lisp has is the ability to program to create programs because it uses the idea of a macro (this is not the same macro in other langauges). Lisp has shown its power in its program that is used by Orbitz. The 200k line Lisp program that Orbitz used to leapfrog competitors, of course uses macros. So why not use Lisp? Because it's not as popular as new languages that have just recently popped up.
One tiny little note that I liked to see was the reference to the Mythical Man Month book, where Graham says that if you were to add more people to program in a lower effective programming language then there would be a net loss. This is because different programming languages have varying amounts of code which equates to varying amounts of time, and we all know that time equals money. 

# Read another chapter from Hackers and Painters - Chapter 12 Beating the Averages
In this chapter Graham harps from his podium about his experiences, uses, and greatness of the programming language Lisp. I now know after reading this chapter why the chapter after this had a lot of emphasis on explaining how great Lisp was. I feel there is a lot of bias in this chapter because Lisp seems to be a language that Graham utilized a lot and is very familiar with, so maybe that's why he feels that everyone should learn it or use it in the business world. He proposes three levels for hackers, the first level starting with Python or Java since they are easy to pick up, then C, and then finally the serious hacker would learn Lisp. Graham chose Lisp in his startup because he would be able to get features done faster than competitors. The High-Level learning requirement of Lisp would also mean that the development team would be small as well. Lower the cost, lower the risk, and lower the complexity.

